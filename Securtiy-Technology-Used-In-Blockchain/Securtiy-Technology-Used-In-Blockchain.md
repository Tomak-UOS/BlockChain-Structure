# 블록체인에 사용되는 보안 기술

목차
1. 보안의 기본
2. 해시 함수(Hash Function)
3. 머클 트리(Merkle Tree)
4. 공개키 암호 방식
5. 전자 서명(Digital Signiture)


## 1. 보안의 기본

인터넷을 경유해서 데이터를 전달할 때 데이터는 다양한 네트워크나 장비를 경유해서 목적지에 도달하게 된다. 이 모델에서 데이터를 안전하게 전달하기 위해서는 보안 기술이 필요하다. 먼저 인터넷에서 데이터를 주고 받을 때 발생할 수 있는 문제들을 간단한 그림으로 살펴보자.

### 1. 도청

![도청](http://i68.tinypic.com/1216atj.png)

A가 B에게 메시지를 전송할 때 경로 상에 있는 X가 메시지 내용을 훔쳐볼 가능성이 있다. 이 문제를 '도청'이라고 한다.

### 2. 위장

![위장1](http://i63.tinypic.com/2yzde2t.png)

![위장2](http://i65.tinypic.com/2ci8suw.png)

A는 B에게 메시지를 전달했다고 생각하지만, X가 B로 위장했을 가능성이 있다. 반대로 B가 A에게 메시지를 받았다고 생각하지만, 실제로 X가 A로 위장하여 보낸 메시지일 수 있다. 이 문제를 '위장' 이라고 한다.

### 3. 변조

![변조](http://i68.tinypic.com/2laeq12.png)

A가 B에게 메시지 전송을 환료했다고 해도, 도중에 X가 메시지 내용을 변경했을 가능성이 있다. 이 문제를 '변조' 라고 한다. (제 3자가 의도적으로 변조한 것 이외에도 전송상의 문제 등으로 데이터가 망가진 상태로 전달될 수 있다.)

### 4. 사후 부인

![사후 부인 전](http://i63.tinypic.com/2mbg93.png)

B는 A에게 메시지를 받았지만,

![사후 부인 후](http://i68.tinypic.com/2zpipgz.png)

메시지 전송자인 A가 악의를 지닌 경우, '그건 내가 보낸 것이 아니다'라고 부인할 가능성이 있다. 이런 경우에는 네트워크 상 거래나 계약 행위가 성립하지 않게 된다.이 문제를 '사후 부인'이라고 한다.

위 문제들은 일상적으로 사용하는 인터넷 환경 뿐만 아니라 블록체인 네트워크에도 동일하게 발생할 수 있는 문제이다. 그럼 블록체인 네트워크에서는 이 보안적인 문제에 어떻게 대처를 하고 있는지 알아보자.


## 2. 해시 함수(Hash Function)

해시 함수란 주어진 데이터를 고정 길이의 불규칙적인 숫자 변환하는 함수이다. 아래의 믹서기 그림으로 쉽게 이해할 수 있다.

![해쉬 모델](http://i64.tinypic.com/2rr6qop.png)

위 그림처럼 데이터를 해시 함수에 넣게 되면 불규칙한 숫자를 출력한다. 이 출력된 숫자를 '해시값'이라고 한다. 해시값은 숫자이지만 그림에서 보는 것과 같이 16진수로 표기하는 경우가 많다. 컴퓨터는 모든 데이터를 0과 1로 이루어진 2진수로 관리하고 있다. 이 해시값도 마찬가지로 데이터의 일종이기 때문에 표기는 16진수로 하지만 내부에선 2진수로 관리된다. 실제로 해시 함수는 컴퓨터 내부에서 수치 계산을 하고 있는 것이다.

이런 해시 함수에는 크게 5가지 특징이 있다.

 1. 출력되는 데이터의 길이는 함수에 따라 다르지만, 고정되어 있다.
 2. 입력이 동일하면 출력도 반드시 동일하다.
 3. 입력되는 데이터가 1bit라도 달라지면 출력값은 완전히 달라진다.
 4. 전혀 다른 데이터를 입력해도 동일한 해시값이 나올 수 있다.
 5. 해시값으로 원 데이터를 역산하는 것은 불가능하다.


## 3. 머클 트리(Merkle Tree)
머클 트리는 발명자 랄프 머클의 이름을 따 만든 이름이고, 해시 트리(Hash Tree) 라고도 한다.

![머클 트리](https://upload.wikimedia.org/wikipedia/commons/thumb/9/95/Hash_Tree.svg/800px-Hash_Tree.svg.png)

블록 안의 각각의 데이터를 해싱하여 구한 값을 다른 데이터의 해시값과 연결하여 다시 해싱하면서 이진 트리구조를 완성한다. 이 머클 트리 구조가 블록체인의 신뢰성을 유지시켜 핵심적인 기술이다. 자세한 내용은 아래와 같다.

![블록체인 구조](http://d2.naver.com/content/images/2015/12/helloworld-201512-1502-3.png)

위와 같은 블록체인 구조에서 블록 헤더는 이전 블록의 해시값을 가지게 된다. 악의적인 사용자가 생성된 블록 안의 트랜잭션 내역을 수정하게 되면, 해시 함수의 특성상 생성되는 머클 트리의 해시값이 완전히 달라지게 된다. 따라서 이 악의적인 사용자는 다음에 생성되는 블록들을 다시 만들어 원래의 블록 길이보다 길게 만들어 기존의 블록들을 자신이 만든 블록들로 대체시켜야 한다..

블록체인 기술은 위에서 소개한 해시함수의 5번째 특성인 해시값으로 원 데이터를 역산하는 불가능하기 때문에,  nonce를 증가시키면서 해당하는 해시값과 같거나 그보다 작은 값을 Brute Force 방식으로 찾는 방법을 이용한다. 여기서 확인할 수 있는 점은 이 값을 찾기 위해서는 매우 많은 컴퓨팅 파워가 필요하다는 것이다.

악의적인 사용자는 이 엄청난 컴퓨팅 파워를 소모하면서 다음 블록들을 생성시켜 기존의 정상적인 체인을 포크(fork)시켜야 하는데 사실상 이는 불가능하다. 때문에 블록체인 기술이 안전하다고 하는 것이다.


## 4. 공개키 암호 방식
공개키 암호화 방식은 암호화와 복호화에 서로 다른 키를 사용하는 방식이다. 이때 암호화에 사용되는 키를 '공개키' 복호화에 사용되는 키를 '개인키' 또는 '비밀키'라고 한다. 그림을 통해 공개키 암호 방식을 통한 데이터 교환의 흐름을 살펴보겠다.

![공개키1](http://i66.tinypic.com/1611dlw.png)

1. A가 B에게 데이터를 전송하려고 한다.
2. B는 공개키(PB)와 개인키(SB)를 생성하여 공개키(PB)를 A에게 전달한다.
3. A는 공개키를 이용해 데이터를 암호화하여 B에게 전달한다.
4. B는 개인키를 이용해 암호화된 데이터를 복호화 한다.

여기서 공개키의 장점은 B가 자신의 개인키만 잘 보관하고 있다면, 공개키와 암호화된 데이터를 X가 보더라도 복호화할 수 없다는 점이다.

![공개키2](http://i66.tinypic.com/rr2mc8.png)

또 다른 장점은 공개키는 노출되어도 문제가 없기 때문에 다수의 사용자가 B에게 데이터를 보내는 구조에서도 유용하게 사용될 수 있다.

RSA, Elliptic Curve Cryptography(타원 곡선 암호화)가 이 공개키 암호화 방식의 일종이며 이 중 ECC 방식은 현재 블록체인 네트워크에서 사용되고 있는 방식이다.

그렇다면 '이 암호화 방식은 항상 안전한 방법인가?'라는 생각을 해 볼 수 있다. 결론적으로는 이 방식 또한 취약점을 가지고 있다.

![공개키 취약점 1](http://i65.tinypic.com/noeeyq.png)

1. 악의적인 사용자 X가 공개키 PX와 개인키 SX를 생성한다.
2. B는 자신의 공개키(PB)를 A에게 전달하려고 한다.
3. X는 PB를 가로채 PX로 바꿔서 A에게 보낸다.

![공개키 취약점 2](http://i67.tinypic.com/v7qyip.png)

4. A는 바뀐 공개키 PX로 데이터를 암호화 하여 B에게 전달한다.
5. X는 암호화된 데이터를 가로채 자신의 개인키 SX로 데이터를 복호화 한다.

![공개키 취약점 3](http://i66.tinypic.com/2lawigm.png)

6. X는 가로챈 PB로 다시 복호화된 데이터를 암호화하여 B에게 전송한다.
7. B는 암호화된 데이터를 자신의 개인키 SB로 복호화 한다.

이 공개키 암호 방식에서는 전달받은 공개키를 누가 만든 것인지 확인할 수 있는 수단이 없다. 따라서 A와 B는 정상적으로 데이터를 주고 받은 것처럼 인식하게 된다. 하지만 이 취약점은 '전자 인증서'를 함께 사용해 해결할 수 있다.


## 5. 전자 서명
전자 서명 방식은 공개키 암호 방식을 응용하여 만든 방식이다. 이 방식은 전송자만 작성할 수 있는 '전자 서명'이라는 것을 이용해 데이터의 '변조'와 '사후 부인'을 방지한다.

전자 서명 구조의 흐름은 아래와 같다.

![전자서명1](http://i66.tinypic.com/v47bkl.png)

1. 전송자 A는 공개키(PA)와 개인키(SA)를 만들고 공개키를 B에게 전송한다.

![전자서명2](http://i63.tinypic.com/2h4aik8.png)

2. A는 자신의 데이터를 해싱하여 그 해시값을 개인키로 암호화 해서 자신의 서명으로 사용한다.

![전자서명3](http://i68.tinypic.com/10cko74.png)

3. A는 B에게 데이터와 서명을 전송한다.
4. B는 데이터를 해싱하여 나온 값이 A의 서명을 공개키(PA)로 복호화 한 값과 같은지 확인한다.

이 방법 또한 블록체인에서 사용되는데,블록에 담겨 있는 모든 트랜잭션에 전자 서명이 포함되어 거래 정보가 진본임을 신뢰할 수 있게 한다.

이 방법을 이용하면, ''변조'와 '부인 방지'는 해결할 수 있지만, 한 가지 문제가 발생한다. '데이터를 송신한 사람이 A가 아닐수도 있다.' 라는  '위장'의 문제가 남아 있다.

B는 전자 서명을 이용한 데이터를 교환했기 때문에 전송자가 A라고 생각하고 있지만, 실제로는 A를 사칭한 X에게 데이터를 받았을 가능성이 있다. 이 취약점은 'A라는 사람이 이 공개키와 서명을 했다' 까지는 알 수 있지만, 'A는 누구이다' 라는 A에 대한 정확한 정보가 없고 이 정보를 담아서 보내더라도 그것을 인증할 수 없기 때문에 발생한다. 이 방법 또한 공개키 암호 방식을 응용한 방식이기 때문에 공개키 암호 방식에서도 문제가 된 공개키가 누구 것인지 알 수 없다''라는 점에서 문제가 발생하지만 똑같이 '전자 인증서'로 해결 가능한 문제이다.
